# マルチテナント化実装計画

## Context（背景）

現在のUTAGE3.0システムはシングルテナントを前提としており、複数のIPブランドが混ざる状態でしかサービスを展開できず、クライアント獲得の障害になっています。この実装計画は、PostgreSQL Row Level Security (RLS)を活用したマルチテナント化により、単一のプロダクト基盤を複数の独立したブランドへ横展開可能にすることを目的としています。

**設計方針**:
- PostgreSQL RLSによるデータベースレベルのデータ分離
- サブドメイン（例: `artist-a.utage3.com`）でテナント識別
- Firebase Tenantで認証を分離
- 各テナントで完全に独立したユーザーベース
- 決済データもテナントスコープで管理

**現在の状態**:
- データベース: 16テーブル存在、テナント分離なし
- Go Backend (`packages/api`): 主要バックエンド、Firebase認証あり
- Node.js Backend (`packages/backend`): メンテナンスモード、GraphQL
- Frontend: サブドメイン検出未実装

---

## 実装アプローチ（4つのPhase）

設計ドキュメント（`docs/design-doc/multitenancy.md`）に基づき、段階的に実装します。

### **Phase 1: データベーススキーマ変更**（工数: 2日）

**目的**: テナント分離の基盤となるテーブル構造を準備

**実装内容**:

1. **Tenantテーブル作成**
   - ファイル: `packages/backend/prisma/schema.prisma`
   - 追加するモデル:
     ```prisma
     model Tenant {
       id               String   @id @default(cuid())
       firebaseTenantId String   @unique @map("firebase_tenant_id")
       subdomain        String   @unique
       name             String
       createdAt        DateTime @default(now())
       updatedAt        DateTime @updatedAt
       // Relations: users, events, packs, etc.
     }
     ```

2. **15テーブルにtenant_id追加**
   - 対象: user, event, event_setlist, pack, pack_price, physical_pack, certificate, checkin_code, trading_card, trading_card_benefit, pack_trading_card_relation, quiz_survey, payment_method, payment_transaction, pairing
   - 各テーブルに`tenantId String @map("tenant_id")`と`tenant Tenant @relation(...)`を追加
   - インデックス: `@@index([tenantId])`を追加

3. **マイグレーション戦略**（重要）:
   ```sql
   -- Step 1: tenant_idをNULL許容で追加
   -- Step 2: デフォルトテナントレコード作成
   -- Step 3: 既存データにバックフィル
   -- Step 4: NOT NULL制約追加
   -- Step 5: 外部キー制約追加
   -- Step 6: パフォーマンス用インデックス作成
   ```

**コマンド**:
```bash
cd packages/backend
pnpm prisma migrate dev --name add_tenant_table
pnpm prisma migrate dev --name add_tenant_id_to_all_tables
```

**リスク**: 既存データのバックフィル失敗
**軽減策**: バックアップ取得、ステージング環境で事前テスト

---

### **Phase 2: バックエンド対応**（工数: 5〜7日）

**目的**: RLS適用の仕組みを実装（ただしポリシーは未有効化 = Dry Runモード）

#### **2.1 Go Backend実装**（3〜4日）

**ファイル**: `packages/api/internal/adapter/driver/middleware/firebase.go`

- Firebase TokenのclaimsからFirebase Tenant IDを抽出
- `TenantIDContextKey`をcontextに追加
- 変更箇所:
  ```go
  // Firebase Tenant IDを抽出してcontextに設定
  if tenantClaim, ok := decodedToken.Firebase.Tenant.(string); ok {
      ctx = context.WithValue(ctx, TenantIDContextKey, tenantClaim)
  }
  ```

**新規ファイル**: `packages/api/internal/domain/repository/store/tenant.go`
- TenantRepositoryインターフェース定義
- Firebase Tenant ID → 内部Tenant IDの変換メソッド

**新規ファイル**: `packages/api/internal/db/queries/tenant.sql`
```sql
-- name: GetTenantIDByFirebaseTenantID :one
SELECT id FROM "tenant" WHERE firebase_tenant_id = $1;
```

**ファイル**: `packages/api/internal/adapter/gateway/rds/repository/store.go`（最重要）

- `PgxExecutor.WithTx()`と`ReadOnly()`メソッドに`setTenantContext()`を追加
- トランザクション開始後に`SET LOCAL app.current_tenant_id = $1`を実行
- **Phase 2ではコメントアウトして実装のみ準備**
- 変更箇所:
  ```go
  func (p *PgxExecutor) setTenantContext(ctx context.Context, tx pgx.Tx) error {
      tenantID, ok := middleware.GetTenantIDFromContext(ctx)
      if !ok { return nil }
      // Phase 3で有効化: _, err := tx.Exec(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
      return nil
  }
  ```

#### **2.2 Node.js Backend実装**（2〜3日）

**新規ファイル**: `packages/backend/src/utils/tenantPrisma.ts`

- `createTenantClient(tenantId)`関数を実装
- Prisma Client Extensionで全クエリをトランザクション内実行
- トランザクション開始時に`SET LOCAL`を実行
- **Phase 2ではコメントアウトして実装のみ準備**
  ```typescript
  return prisma.$extends({
    query: {
      $allModels: {
        async $allOperations({ args, query }) {
          return prisma.$transaction(async (tx) => {
            // Phase 3で有効化: await tx.$executeRaw`SET LOCAL ...`
            return query(args);
          });
        }
      }
    }
  });
  ```

**ファイル**: `packages/backend/src/context.ts`

- Firebase Token claimsからFirebase Tenant IDを抽出
- `tenantId`と`tenantClient`をContextInjectに追加
- 変更箇所:
  ```typescript
  const firebaseTenantId = decoded.firebase?.tenant as string | undefined;
  const tenantId = firebaseTenantId || "default-tenant-id";
  return {
    repository, sideEffect, config,
    uid: decoded.uid,
    tenantId,
    tenantClient: createTenantClient(tenantId),
  };
  ```

**Phase 2完了時点**: バックエンドは`SET LOCAL`の仕組みを実装済みだが、実行はコメントアウト状態。既存のアプリケーション動作に影響なし。

---

### **Phase 3: RLS有効化**（工数: 3〜4日）

**目的**: データベースレベルでテナント分離を強制

**注意**: 本番環境への影響が大きいため、ステージング環境で十分にテスト後に実施

#### **3.1 RLSポリシー定義**（1日）

**新規マイグレーション**: `packages/backend/prisma/migrations/YYYYMMDDHHMMSS_enable_rls_policies/migration.sql`

```sql
-- 15テーブル全てでRLSを有効化
ALTER TABLE "user" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "event" ENABLE ROW LEVEL SECURITY;
-- ... 残り13テーブルも同様

-- 各テーブルにポリシー作成
CREATE POLICY tenant_isolation_policy ON "user"
    FOR ALL
    USING ("tenant_id" = current_setting('app.current_tenant_id', true))
    WITH CHECK ("tenant_id" = current_setting('app.current_tenant_id', true));

-- ... 残り14テーブルも同様のポリシー
```

**ポリシーの意味**:
- `FOR ALL`: SELECT/INSERT/UPDATE/DELETE全操作に適用
- `USING`: クエリ実行時のフィルタリング条件
- `WITH CHECK`: INSERT/UPDATE時のバリデーション条件
- `current_setting('app.current_tenant_id', true)`: セッション変数から取得（第2引数trueでNULL許容）

#### **3.2 SET LOCAL有効化**（0.5日）

**Phase 2でコメントアウトしたコードを有効化**:

1. Go Backend: `packages/api/internal/adapter/gateway/rds/repository/store.go`の`setTenantContext()`内のコメント解除
2. Node.js Backend: `packages/backend/src/utils/tenantPrisma.ts`の`tx.$executeRaw`コメント解除

#### **3.3 テスト戦略**（2〜3日）

**ステージング環境でのテスト**:
1. 2つのテナント（tenant-a, tenant-b）を作成
2. 各テナントでユーザー登録・ログイン
3. テナントAでログイン → テナントBのデータが見えないことを確認
4. 主要フロー（決済、チェックイン、カード獲得）をテナント別に実行
5. データベース直接確認でtenant_idの整合性を検証

**ユニットテスト**:
- Go: `packages/api/internal/adapter/gateway/rds/repository/store_test.go` - RLS分離のテスト
- Node.js: `packages/backend/src/utils/tenantPrisma.test.ts` - Prisma拡張のテスト

**モニタリング**:
- エラーログ監視（RLSポリシー違反エラー）
- クエリパフォーマンス（Phase 2比でレイテンシ変化を監視）

**ロールバック手順**（緊急時）:
```sql
-- 全テーブルのRLSを一時的に無効化
ALTER TABLE "user" DISABLE ROW LEVEL SECURITY;
-- ... 残り14テーブルも同様
```

---

### **Phase 4: リファクタリング**（工数: 3〜4日）

**目的**: RLS稼働確認後、冗長なコードを削除

**実装内容**:

1. **冗長なWHERE句の削除**（2〜3日）
   - 対象: `packages/backend/src/infra/repository/*.ts`（全7ファイル）
   - 対象: `packages/api/internal/db/queries/*.sql`（全4ファイル）
   - 例: `WHERE user.tenantId = $1`のような明示的なフィルタリングを削除（RLSが自動適用）
   - **注意**: RLSが確実に機能していることを確認してから削除

2. **パフォーマンス最適化**（1日）
   - `EXPLAIN ANALYZE`でクエリプラン確認
   - 複合インデックスの追加（必要に応じて）:
     ```sql
     CREATE INDEX user_tenant_id_email_idx ON "user"(tenant_id, email);
     CREATE INDEX event_tenant_id_start_date_idx ON "event"(tenant_id, start_date);
     ```

---

## サブドメイン検出とFirebase Tenant統合（工数: 3〜4日）

**並行実装可能**（Phase 2と同時進行可）

### **フロントエンド実装**

**新規ファイル**: `packages/web/app/utils/tenant.ts`

```typescript
// サブドメインからFirebase Tenant IDを解決
export function getSubdomain(): string {
  const hostname = window.location.hostname;
  // artist-a.utage3.com → "artist-a"
  return hostname.split(".")[0] || "default";
}

// API経由でFirebase Tenant ID取得（推奨）
export async function fetchFirebaseTenantId(subdomain: string): Promise<string> {
  const response = await fetch(`/api/tenant/resolve?subdomain=${subdomain}`);
  return (await response.json()).firebaseTenantId;
}
```

**ファイル**: `packages/web/app/features/auth/Auth.tsx`（推測）

- Firebase Auth初期化時にテナントIDを設定:
  ```typescript
  const auth = getAuth();
  auth.tenantId = await fetchFirebaseTenantId(getSubdomain());
  ```

### **バックエンド実装**

**新規ファイル**: `packages/api/internal/adapter/driver/proto/tenant.go`

- サブドメイン → Firebase Tenant ID解決エンドポイント
- `ResolveTenant` RPCメソッド実装
- TenantRepositoryでDBから取得

**新規ファイル**: `proto/api/v1/tenant.proto`（必要に応じて）

```protobuf
message ResolveTenantRequest {
  string subdomain = 1;
}

message ResolveTenantResponse {
  string firebase_tenant_id = 1;
  string tenant_name = 2;
}
```

---

## Critical Files（重要な変更ファイル一覧）

### Phase 1: データベース
- `packages/backend/prisma/schema.prisma` - Tenantモデルと全テーブルへのtenant_id追加

### Phase 2: バックエンド
- **Go Backend**:
  - `packages/api/internal/adapter/gateway/rds/repository/store.go` - SET LOCAL実行ポイント（最重要）
  - `packages/api/internal/adapter/driver/middleware/firebase.go` - テナントID抽出
  - `packages/api/internal/domain/repository/store/tenant.go` - TenantRepository（新規）
  - `packages/api/internal/db/queries/tenant.sql` - テナント解決クエリ（新規）

- **Node.js Backend**:
  - `packages/backend/src/utils/tenantPrisma.ts` - Prisma Client拡張（新規）
  - `packages/backend/src/context.ts` - テナントID抽出とContext追加

### Phase 3: RLS
- `packages/backend/prisma/migrations/YYYYMMDDHHMMSS_enable_rls_policies/migration.sql` - RLSポリシー定義

### Frontend & Tenant:
- `packages/web/app/utils/tenant.ts` - サブドメイン検出（新規）
- `packages/web/app/features/auth/Auth.tsx` - Firebase Tenant設定

---

## Verification（検証方法）

### ステージング環境での統合テスト

1. **テナント作成**:
   ```sql
   INSERT INTO "tenant" (id, firebase_tenant_id, subdomain, name)
   VALUES
     ('tenant-a', 'firebase-tenant-a', 'artist-a', 'Artist A'),
     ('tenant-b', 'firebase-tenant-b', 'artist-b', 'Artist B');
   ```

2. **ユーザー登録**:
   - `artist-a.staging.utage3.com`でユーザーAを登録
   - `artist-b.staging.utage3.com`でユーザーBを登録

3. **データ分離確認**:
   - ユーザーAでログイン → テナントBのイベント・パックが見えないことを確認
   - 決済処理 → payment_transactionのtenant_idが正しく設定されていることを確認

4. **RLS動作確認**:
   ```sql
   -- テナントAのコンテキストでクエリ実行
   SET LOCAL app.current_tenant_id = 'tenant-a';
   SELECT * FROM "user"; -- テナントAのユーザーのみ表示

   -- テナントBのコンテキストに切り替え
   SET LOCAL app.current_tenant_id = 'tenant-b';
   SELECT * FROM "user"; -- テナントBのユーザーのみ表示
   ```

5. **パフォーマンステスト**:
   - 負荷テストツール（k6など）でPhase 2とPhase 3のレイテンシを比較
   - 目標: 20%以内の劣化

---

## リスク評価

### 高リスク
1. **RLS有効化時のデータアクセス不可** - ポリシー設定ミスで全データアクセス不可
   - 軽減策: ステージング環境で十分テスト、本番は低トラフィック時間帯

2. **SET LOCALの実行漏れ** - テナントID未設定で誤ったデータアクセス
   - 軽減策: 全トランザクション開始点で必ず実行、ユニットテストで検証

### 中リスク
3. **既存データのバックフィル失敗** - Phase 1でのデータ移行エラー
   - 軽減策: バックアップ取得、トランザクション内で実行

4. **Firebase Tenant設定の複雑さ** - テナント別認証の設定ミス
   - 軽減策: 設定チェックリスト作成、ドキュメント化

### 低リスク
5. **パフォーマンス劣化** - SET LOCALとRLSのオーバーヘッド
   - 軽減策: インデックス最適化、ステージングで負荷テスト

---

## 実装スケジュール（概算）

| Phase | 工数 | 並行可能タスク |
|-------|------|----------------|
| Phase 1: スキーマ変更 | 2日 | - |
| Phase 2: バックエンド実装 | 5〜7日 | サブドメイン実装（3〜4日）と並行可 |
| Phase 3: RLS有効化 | 3〜4日 | - |
| Phase 4: リファクタリング | 3〜4日 | - |

**合計**: 13〜17営業日（約3〜4週間）

**依存関係**: Phase 1 → Phase 2 → Phase 3 → Phase 4（順次実行必須）

---

## 未解決事項

1. **管理ツール（Admin Package）のマルチテナント対応**
   - 全テナントのデータにアクセスする必要がある
   - 対応策: 管理者用DBユーザーでRLSバイパス、または動的なSET LOCAL切替

2. **本番環境でのゼロダウンタイム移行**
   - Blue-Green DeploymentまたはCanary Releaseの検討

3. **Firebase Tenant作成の自動化**
   - 新テナント追加時のFirebase Tenant自動作成フロー
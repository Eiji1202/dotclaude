import { GraphQLError } from "graphql/error";
import type { ContextInject } from "~/context";
import type {
  PackMapper,
  PackPriceMapper,
  TradingCardBenefitMapper,
  TradingCardMapper,
  UserTradingCardMapper,
} from "~/graphql/pack/schema.mappers";
import type {
  GrantPackInput,
  GrantPackResponse,
  UseTradingCardBenefitInput,
} from "~/graphql/types.generated";
import { EventDataSource } from "~/usecase/event";
import { assertAuthenticated } from "~/utils/assertAuthenticated";
import { assertExists } from "~/utils/assetExists";
import { toJST } from "~/utils/date";
import { logger } from "~/utils/logger";

export class PackDataSource {
  private context: ContextInject;

  public constructor(context: ContextInject) {
    this.context = context;
  }

  // 指定されたIDのパック情報を取得する。
  public async getPack(packId: string): Promise<PackMapper> {
    const repo = this.context.repository.pack;
    const pack = await repo.findUniquePack(packId);
    assertExists(pack, "Pack");

    return pack;
  }

  // パック一覧を取得する。
  public async getPacks(): Promise<PackMapper[]> {
    return this.context.repository.pack.findManyPublicAndPurchasablePacks();
  }

  // ユーザーが所有するデジタルトレカを取得する。
  public async getUserTradingCard(
    userTradingCardId: string,
  ): Promise<UserTradingCardMapper | null> {
    logger.info("getUserTradingCard", { userTradingCardId });
    const uid = this.context.uid;
    if (!uid) {
      logger.warn("User is not authenticated", { userTradingCardId });
      return null;
    }

    const repo = this.context.repository.pack;
    const userTradingCard =
      await repo.findUniqueUserTradingCardWithTradingCard(userTradingCardId);

    if (!userTradingCard || userTradingCard.userId !== uid) {
      logger.warn("User trading card does not belong to you", {
        userTradingCardId,
        uid,
      });
      return null;
    }

    return {
      ...userTradingCard,
      name: userTradingCard.tradingCard.name,
      imageURL: userTradingCard.tradingCard.imageURL,
      backImageURL: userTradingCard.tradingCard.backImageURL,
      usedImageURL: userTradingCard.tradingCard.usedImageURL,
    };
  }

  // ユーザーが所有するデジタルトレカを取得する。（認証不要）
  public async getPublicUserTradingCard(
    userTradingCardId: string,
  ): Promise<UserTradingCardMapper | null> {
    logger.info("getPublicUserTradingCard", { userTradingCardId });

    const repo = this.context.repository.pack;
    const userTradingCard =
      await repo.findUniqueUserTradingCardWithTradingCard(userTradingCardId);

    if (!userTradingCard) {
      logger.warn("User trading card not found", { userTradingCardId });
      return null;
    }

    return {
      ...userTradingCard,
      name: userTradingCard.tradingCard.name,
      imageURL: userTradingCard.tradingCard.imageURL,
      backImageURL: userTradingCard.tradingCard.backImageURL,
      usedImageURL: userTradingCard.tradingCard.usedImageURL,
    };
  }

  // 認証状態に応じてユーザーが所有するデジタルトレカを取得する。
  public async getUserTradingCardByAuth(
    userTradingCardId: string,
  ): Promise<UserTradingCardMapper | null> {
    const uid = this.context.uid;
    logger.info("getUserTradingCardByAuth", { userTradingCardId, uid });

    if (uid) {
      return await this.getUserTradingCard(userTradingCardId);
    }
    return await this.getPublicUserTradingCard(userTradingCardId);
  }

  // ユーザーが所有するデジタルトレカからパック情報を取得する。
  public async getPackByUserTradingCardId(
    userTradingCardId: string,
  ): Promise<PackMapper> {
    const repo = this.context.repository.pack;

    const userTradingCard =
      await repo.findUniqueUserTradingCard(userTradingCardId);
    assertExists(userTradingCard, "UserTradingCard");

    const relation = await repo.findFirstPackTradingCardRelationWithPack(
      userTradingCard.tradingCardId,
    );
    assertExists(relation, "PackTradingCardRelation");

    return relation.pack;
  }

  // トレカIDベースにでユーザーが所有するトレカを一枚取得する。
  public async getUserTradingCardByTradingCardId(
    tradingCardId: string,
  ): Promise<UserTradingCardMapper | null> {
    const repo = this.context.repository.pack;
    const uid = this.context.uid;
    if (!uid) {
      logger.warn("User is not authenticated", { tradingCardId });
      return null;
    }

    const userTradingCard = await repo.findFirstUserTradingCardByTradingCardId(
      uid,
      tradingCardId,
    );
    if (!userTradingCard) {
      return null;
    }

    return {
      ...userTradingCard,
      name: userTradingCard.tradingCard.name,
      imageURL: userTradingCard.tradingCard.imageURL,
      backImageURL: userTradingCard.tradingCard.backImageURL,
      usedImageURL: userTradingCard.tradingCard.usedImageURL,
    };
  }

  // 指定されたパックが購入可能かどうかを取得する。
  public async isPackPurchasable(packId: string): Promise<boolean> {
    // パックの価格情報が存在しない場合は購入不可とする
    const prices = await this.getPackPrices(packId);
    if (prices.length === 0) {
      return false;
    }
    return true;
  }

  // 指定されたパックの価格情報を取得する。
  public async getPackPrices(packId: string): Promise<PackPriceMapper[]> {
    return this.context.repository.pack.findManyPackPrices(packId);
  }

  // 指定されたパックのデジタルトレカ一覧を取得する。
  public async getTradingCardsByPackId(
    packId: string,
  ): Promise<TradingCardMapper[]> {
    const repo = this.context.repository.pack;
    const relations =
      await repo.findManyPackTradingCardRelationsWithTradingCard(packId);

    const cardPromises = relations.map(async (relation) => {
      const [totalCount, viewerOwnedCount] = await Promise.all([
        repo.countUserTradingCardsByTradingCardId(relation.tradingCardId),
        repo.countUserTradingCardsByTradingCardIdAndUserId(
          relation.tradingCardId,
          this.context.uid || "",
        ),
      ]);

      return {
        ...relation.tradingCard,
        maxCount: relation.maxCount,
        isSoldOut: relation.maxCount === totalCount,
        viewerOwnedCount,
      };
    });

    const cards = await Promise.all(cardPromises);

    // NOTE: UTAGE Crew のパックは created_at でソートする
    if (packId === "1b6abfe0c6e34c729f9adf70e3b97a36") {
      return cards.sort((a, b) => {
        const createdAtA = a.createdAt.getTime();
        const createdAtB = b.createdAt.getTime();
        return createdAtA - createdAtB;
      });
    }

    return sortCards(cards);
  }

  // 指定されたパックからデジタルトレカをランダムに選択する。
  public async selectRandomTradingCardIdsByPackId(
    operation: "checkin" | "payment",
    packId: string,
    qty: number,
  ): Promise<string[]> {
    const repo = this.context.repository.pack;
    const sideEffect = this.context.sideEffect;
    const now = sideEffect.clock();

    const relations =
      await repo.findManyPackTradingCardRelationsWithTradingCard(packId);

    // 公開済みのカードのみ当選する（nullは公開済みとして扱う）
    const revealedRelations = relations.filter((relation) => {
      const revealedAt = relation.tradingCard.revealedAt;
      return (
        revealedAt == null ||
        now.isAfter(toJST(revealedAt)) ||
        now.isSame(toJST(revealedAt))
      );
    });

    // デジタルトレカごとの最大配布数
    const maxCountMap = new Map(
      revealedRelations.map((relation) => [
        relation.tradingCardId,
        relation.maxCount,
      ]),
    );

    const distributedCounts =
      await repo.groupByTradingCardIdByRelations(revealedRelations);

    // デジタルトレカごとの配布済み数
    const distributedCountMap = new Map(
      distributedCounts.map((card) => [card.tradingCardId, card._count]),
    );

    // グループ化（group が設定されている場合はグループごとに分ける）
    const groupToRelations = new Map<string, typeof revealedRelations>();
    for (const rel of revealedRelations) {
      const groupKey = rel.tradingCard.group ?? rel.tradingCardId;
      if (!groupToRelations.has(groupKey)) {
        groupToRelations.set(groupKey, []);
      }
      groupToRelations.get(groupKey)?.push(rel);
    }

    const effectiveRelations: typeof revealedRelations = [];
    for (const groupRelations of groupToRelations.values()) {
      // 確率が低い順（レア順）に並び替える
      groupRelations.sort((a, b) => {
        const chanceA = operation === "payment" ? a.paidChance : a.chance;
        const chanceB = operation === "payment" ? b.paidChance : b.chance;
        return chanceA - chanceB;
      });

      // グループ内で、配布可能なカードのうち一番排出率の低いものを採用する（0%のカードは除外）
      const usable = groupRelations.find((r) => {
        const max = maxCountMap.get(r.tradingCardId);
        const count = distributedCountMap.get(r.tradingCardId) ?? 0;
        const chance = operation === "payment" ? r.paidChance : r.chance;
        return (max == null || count < max) && chance > 0;
      });

      if (usable) {
        effectiveRelations.push(usable);
      }
    }

    // 排出確率の合計を計算
    const totalChance = effectiveRelations.reduce((sum, relation) => {
      const chance =
        operation === "payment" ? relation.paidChance : relation.chance;
      return sum + chance;
    }, 0);

    const selectedCardIds: string[] = [];
    const selectedCardCounts: Record<string, number> = {};

    while (selectedCardIds.length < qty && effectiveRelations.length > 0) {
      // 重み付きランダム選択
      const random = Math.random() * totalChance;
      let currentSum = 0;
      let selectedRelation: (typeof revealedRelations)[0] | null = null;

      for (const relation of effectiveRelations) {
        const chance =
          operation === "payment" ? relation.paidChance : relation.chance;
        currentSum += chance;
        if (random <= currentSum) {
          selectedRelation = relation;
          break;
        }
      }

      if (!selectedRelation) {
        // 浮動小数点の計算誤差がある場合のフォールバック
        selectedRelation = effectiveRelations[0];
      }

      const selectedCardId = selectedRelation.tradingCardId;
      const maxCount =
        maxCountMap.get(selectedCardId) ?? Number.POSITIVE_INFINITY;
      const distributedCount = distributedCountMap.get(selectedCardId) ?? 0;
      const selectedCount = selectedCardCounts[selectedCardId] ?? 0;

      // 配布済み数と選択済み数の合計が最大配布数を超えていない場合、選択済みカードに追加し、
      // 選択済み数を更新する
      if (distributedCount + selectedCount < maxCount) {
        selectedCardIds.push(selectedCardId);
        selectedCardCounts[selectedCardId] = selectedCount + 1;
      }

      // 最大配布数に達したカードはリストから削除する
      if (distributedCount + selectedCount >= maxCount) {
        const index = effectiveRelations.findIndex(
          (r) => r.tradingCardId === selectedCardId,
        );
        if (index > -1) {
          effectiveRelations.splice(index, 1);
        }
      }
    }

    // 選択済みカード数が qty 個に満たない場合はエラーを返す。このエラーが出た際は、
    // 排出確率が正しく設定されていない可能性があるため、DBを確認する必要がある。
    if (selectedCardIds.length < qty) {
      logger.warn("Not enough trading cards", {
        packId,
        qty,
        selectedCardIds,
        distributedCountMap,
        maxCountMap,
      });
      throw new GraphQLError(
        `Not enough trading cards: required=${qty}, selected=${selectedCardIds.length}`,
        {
          extensions: { code: "INTERNAL_SERVER_ERROR" },
        },
      );
    }

    return selectedCardIds;
  }

  // デジタルトレカの特典を取得する。
  public async getBenefitByTradingCardId(
    tradingCardId: string,
  ): Promise<TradingCardBenefitMapper | null> {
    const repo = this.context.repository.pack;

    const tradingCard =
      await repo.findUniqueTradingCardByIdWithBenefit(tradingCardId);
    assertExists(tradingCard, "TradingCard");

    return tradingCard.benefit;
  }

  // ユーザーが所有するデジタルトレカの特典を取得する。
  public async getBenefitByUserTradingCardId(
    userTradingCardId: string,
  ): Promise<TradingCardBenefitMapper | null> {
    const repo = this.context.repository.pack;

    const userTradingCard =
      await repo.findUniqueUserTradingCardWithBenefit(userTradingCardId);
    assertExists(userTradingCard, "UserTradingCard");

    return userTradingCard.tradingCard.benefit;
  }

  // ユーザーが所有するデジタルトレカの特典が使用済みかどうかを取得する。
  public async isBenefitUsed(userTradingCardId: string): Promise<boolean> {
    const repo = this.context.repository.pack;

    const benefit = await this.getBenefitByUserTradingCardId(userTradingCardId);
    if (!benefit) {
      return false;
    }

    const benefitTransactionCount =
      await repo.countTradingCardBenefitExchangeTransactionsByUserTradingCardId(
        userTradingCardId,
      );

    return benefitTransactionCount > 0;
  }

  // 指定されたデジタルトレカ特典を使用する。
  public async useTradingCardBenefit(
    input: UseTradingCardBenefitInput,
  ): Promise<boolean> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.pack;
    const sideEffect = this.context.sideEffect;

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    const userTradingCard = await repo.findUniqueUserTradingCardWithBenefit(
      input.userTradingCardId,
    );
    assertExists(userTradingCard, "UserTradingCard");

    if (userTradingCard.userId !== uid) {
      logger.warn("User trading card does not belong to you", {
        uid,
        userTradingCardId: input.userTradingCardId,
      });
      throw new GraphQLError("User trading card does not belong to you", {
        extensions: { code: "FORBIDDEN" },
      });
    }

    const benefit = userTradingCard.tradingCard?.benefit;
    assertExists(benefit, "TradingCardBenefit");

    const hasUsed = await this.isBenefitUsed(userTradingCard.id);
    if (hasUsed) {
      logger.warn("Benefit has already been used", {
        uid,
        userTradingCardId: input.userTradingCardId,
      });
      throw new GraphQLError("Benefit has already been used", {
        extensions: { code: "ALREADY_USED" },
      });
    }

    const now = sideEffect.clock();
    const expirationDate = toJST(benefit.expirationDate);
    if (now.isAfter(expirationDate)) {
      logger.warn("Benefit has expired", {
        uid,
        userTradingCardId: input.userTradingCardId,
      });
      throw new GraphQLError("Benefit has expired", {
        extensions: { code: "EXPIRED" },
      });
    }

    await repo.createTradingCardBenefitExchangeTransaction({
      uid,
      userTradingCardId: userTradingCard.id,
      exchangedAt: now.toDate(),
      tenantId: user.tenantId,
    });

    return true;
  }

  // 特定のパックをユーザーに付与する
  public async grantPack(input: GrantPackInput): Promise<GrantPackResponse> {
    const repo = this.context.repository.pack;

    const uid = assertAuthenticated(this.context.uid);

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    const pack = await repo.findUniquePack(input.packId);
    assertExists(pack, "Pack");

    if (!(await this.isPackPurchasable(input.packId))) {
      logger.warn("Pack is not purchasable", {
        uid,
        packId: input.packId,
      });
      throw new GraphQLError("Pack is not purchasable", {
        extensions: { code: "NOT_PURCHASABLE" },
      });
    }

    // checkin をしているか確認する
    const checkinTransactionCount =
      await repo.countCheckinTransactionsByUserIdAndEventId(uid, input.eventId);

    // checkin してない場合、自動で checkin する
    if (checkinTransactionCount === 0) {
      // 対象の type: PER_EVENT の checkin code を検索する
      const checkinCode = await repo.findFirstCheckinCodeByEventId(
        input.eventId,
        "PER_EVENT",
      );

      if (checkinCode == null) {
        // checkin code が存在しない場合はエラーを返す
        logger.warn("Can not auto checkin", {
          uid,
          eventId: input.eventId,
        });
        throw new GraphQLError("Can not auto checkin", {
          extensions: { code: "CAN_NOT_AUTO_CHECKIN" },
        });
      }

      // checkin code を利用して checkin する
      const eventDataSource = new EventDataSource(this.context);

      await eventDataSource.checkin({ code: checkinCode.id });
    }

    if (input.physicalId) {
      // PhysicalPackの存在確認
      const exists = await repo.existPhysicalPack(
        input.eventId,
        input.packId,
        input.physicalId,
      );

      if (!exists) {
        logger.warn("Invalid physical pack", {
          eventId: input.eventId,
          packId: input.packId,
          physicalId: input.physicalId,
        });
        throw new GraphQLError("Invalid physical pack", {
          extensions: { code: "INVALID_PHYSICAL_PACK" },
        });
      }
    }

    const orderId = input.physicalId
      ? `grant-${input.eventId}-${input.packId}-${input.physicalId}`
      : `grant-${input.eventId}-${input.packId}-${uid}`;

    // すでにこのイベントでキャンペーンを受け取っていたらエラー
    const campaignTransactionCount =
      await repo.countPaymentTransactionsByOrderId(orderId);

    if (campaignTransactionCount > 0) {
      logger.warn("Campaign has already been received", {
        uid,
        orderId,
        campaignTransactionCount,
      });
      throw new GraphQLError("Campaign has already been received", {
        extensions: { code: "ALREADY_RECEIVED" },
      });
    }

    // キャンペーンとしてトレカを配布する
    await repo.withTransaction(async (tx) => {
      // キャンペーンとしてDBの PaymentMethod を登録する
      const paymentMethod = await repo.createPaymentMethod({
        userId: uid,
        type: input.physicalId ? "PHYSICAL" : "CAMPAIGN",
        tenantId: user.tenantId,
      });

      // 決済金額 0 円として PaymentTransaction を登録する
      const paymentTransaction = await repo.createCampaignPaymentTransaction({
        userId: uid,
        orderId,
        paymentMethodId: paymentMethod.id,
        packId: input.packId,
        totalPrice: 0,
        quantity: 1,
        tenantId: user.tenantId,
      });

      // NOTE: パック購入時の配布数ではなく、1枚で固定する
      const selectedCardIds = await this.selectRandomTradingCardIdsByPackId(
        "payment",
        input.packId,
        1,
      );

      // userTradingCard に購入したカードを登録する
      await repo.createManyUserTradingCards({
        userId: uid,
        paymentTransactionId: paymentTransaction.id,
        tradingCardIds: selectedCardIds,
        tenantId: user.tenantId,
      });

      const userTradingCards =
        await repo.findManyUserTradingCardsByPaymentTransactionIdAndUserIdWithTradingCard(
          {
            paymentTransactionId: paymentTransaction.id,
            userId: uid,
          },
        );

      const cards: UserTradingCardMapper[] = [];

      for (const card of userTradingCards) {
        cards.push({
          ...card,
          id: card.id,
          name: card.tradingCard.name,
          imageURL: card.tradingCard.imageURL,
          backImageURL: card.tradingCard.backImageURL,
          usedImageURL: card.tradingCard.usedImageURL,
        });
      }

      return cards;
    });

    return {
      orderId,
    };
  }
}

// デジタルトレカのリストをユーザー向けの表示順に並べ替える。
// カードは、名前順でソートされ、同じ名前のカードがある場合は特典がないものを上に表示する。
export function sortCards(cards: TradingCardMapper[]): TradingCardMapper[] {
  return cards.sort((x, y) => {
    const nameComparison = x.name.localeCompare(y.name);
    if (nameComparison !== 0) {
      return nameComparison;
    }
    // 名前が同じ場合は、特典がないものを上に表示する
    return x.benefitId == null ? -1 : 1;
  });
}

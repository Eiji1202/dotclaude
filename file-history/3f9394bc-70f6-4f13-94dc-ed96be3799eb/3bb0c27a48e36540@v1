import type { PackTradingCardRelation, Prisma } from "@/prisma/generated";
import { randomUUID } from "node:crypto";
import { logger } from "~/utils/logger";
import { prisma } from "~/utils/prisma";
import { defaultOption, type Option } from "./utils";

export class PackRepository {
  public async withTransaction<T>(
    fn: (tx: Prisma.TransactionClient) => Promise<T>,
  ) {
    return prisma.$transaction(fn);
  }

  public async findUniquePack(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.pack.findUnique({ where: { id } });
  }

  public async findManyPublicAndPurchasablePacks(
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.pack.findMany({
      where: {
        public: true, // 公開されているパック
        packPrices: { some: {} }, // 販売可能なパック
      },
      orderBy: { createdAt: "desc" },
    });
  }

  public async findUniqueUserTradingCard(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.userTradingCard.findUnique({ where: { id } });
  }

  public async findUniqueUserTradingCardWithTradingCard(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    logger.info("findUniqueUserTradingCardWithTradingCard", { id });
    const { tx } = { ...defaultOption, ...option };

    return tx.userTradingCard.findUnique({
      where: { id },
      include: { tradingCard: true },
    });
  }

  public async findFirstUserTradingCardByTradingCardId(
    uid: string,
    tradingCardId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    // First, try to find a card with no benefit exchange transactions
    const unusedCard = await tx.userTradingCard.findFirst({
      where: {
        userId: uid,
        tradingCardId,
        tradingCardBenefitExchangeTransactions: {
          none: {},
        },
      },
      include: { tradingCard: true },
      orderBy: { createdAt: "asc" },
    });

    if (unusedCard) {
      return unusedCard;
    }

    // If no unused card found, return any card for this tradingCardId
    return tx.userTradingCard.findFirst({
      where: { userId: uid, tradingCardId },
      include: { tradingCard: true },
      orderBy: { createdAt: "asc" },
    });
  }

  public async findUniqueUserTradingCardWithBenefit(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.userTradingCard.findUnique({
      where: { id },
      include: { tradingCard: { include: { benefit: true } } },
    });
  }

  public async findFirstPackTradingCardRelationWithPack(
    tradingCardId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.packTradingCardRelation.findFirst({
      where: { tradingCardId },
      include: { pack: true },
    });
  }

  public async findManyPackPrices(
    packId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.packPrice.findMany({ where: { packId } });
  }

  public async findManyPackTradingCardRelationsWithTradingCard(
    packId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.packTradingCardRelation.findMany({
      where: { packId },
      include: { tradingCard: true },
    });
  }

  public async countUserTradingCardsByTradingCardId(
    tradingCardId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.userTradingCard.count({ where: { tradingCardId } });
  }

  public async countUserTradingCardsByTradingCardIdAndUserId(
    tradingCardId: string,
    userId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    return tx.userTradingCard.count({ where: { tradingCardId, userId } });
  }

  public async groupByTradingCardIdByRelations(
    relations: PackTradingCardRelation[],
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.userTradingCard.groupBy({
      by: ["tradingCardId"],
      _count: true,
      where: {
        tradingCardId: {
          in: relations.map(({ tradingCardId }) => tradingCardId),
        },
      },
    });
  }

  public async findUniqueTradingCardByIdWithBenefit(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.tradingCard.findUnique({
      where: { id },
      include: { benefit: true },
    });
  }

  public async countTradingCardBenefitExchangeTransactionsByUserTradingCardId(
    userTradingCardId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.tradingCardBenefitExchangeTransaction.count({
      where: { userTradingCardId },
    });
  }

  public async findUniqueUserById(
    id: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.user.findUnique({ where: { id } });
  }

  public async createTradingCardBenefitExchangeTransaction(
    args: {
      uid: string;
      userTradingCardId: string;
      exchangedAt: Date;
    },
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    const { uid, userTradingCardId, exchangedAt } = args;

    return tx.tradingCardBenefitExchangeTransaction.create({
      data: {
        userId: uid,
        userTradingCardId,
        exchangedAt,
      },
    });
  }

  public async countCheckinTransactionsByUserIdAndEventId(
    userId: string,
    eventId: number,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.checkinTransaction.count({ where: { userId, eventId } });
  }

  public findFirstCheckinCodeByEventId(
    eventId: number,
    type?: "PER_EVENT" | "PER_USER",
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.checkinCode.findFirst({ where: { eventId, type } });
  }

  public async countPaymentTransactionsByOrderId(
    orderId: string,
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };

    return tx.paymentTransaction.count({ where: { orderId } });
  }

  public async createPaymentMethod(
    args: {
      userId: string;
      type: "CARD" | "PAYPAY" | "CAMPAIGN" | "PHYSICAL";
    },
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    const { userId, type } = args;

    return tx.paymentMethod.create({ data: { userId, type } });
  }

  public async createCampaignPaymentTransaction(
    args: {
      userId: string;
      orderId: string;
      paymentMethodId: number;
      packId: string;
      totalPrice: number;
      quantity: number;
    },
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    const { userId, orderId, paymentMethodId, packId, totalPrice, quantity } =
      args;
    const accessId = `campaign-${randomUUID()}`;
    const status = "CAPTURED";
    const capturedAt = new Date();

    return tx.paymentTransaction.create({
      data: {
        userId,
        orderId,
        accessId,
        status,
        paymentMethodId,
        packId,
        totalPrice,
        quantity,
        capturedAt,
      },
    });
  }

  public async createManyUserTradingCards(
    args: {
      userId: string;
      paymentTransactionId: number;
      tradingCardIds: string[];
    },
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    const { userId, paymentTransactionId, tradingCardIds } = args;

    return tx.userTradingCard.createMany({
      data: tradingCardIds.map((tradingCardId) => {
        const id = randomUUID().split("-").join("");

        return {
          id,
          userId,
          paymentTransactionId,
          tradingCardId,
        };
      }),
    });
  }

  public async findManyUserTradingCardsByPaymentTransactionIdAndUserIdWithTradingCard(
    args: {
      paymentTransactionId: number;
      userId: string;
    },
    option: Partial<Option> = defaultOption,
  ) {
    const { tx } = { ...defaultOption, ...option };
    const { paymentTransactionId, userId } = args;

    return tx.userTradingCard.findMany({
      where: { paymentTransactionId, userId },
      include: { tradingCard: true },
    });
  }

  async existPhysicalPack(
    eventId: number,
    packId: string,
    physicalId: string,
    option: Partial<Option> = defaultOption,
  ): Promise<boolean> {
    const { tx } = { ...defaultOption, ...option };

    const count = await tx.physicalPack.count({
      where: { eventId, packId, physicalId },
    });

    return count > 0;
  }
}

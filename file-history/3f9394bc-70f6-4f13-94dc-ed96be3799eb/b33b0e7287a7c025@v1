import { GraphQLError } from "graphql/error";
import {
  PURCHASE_SIGNAGE_REDIRECT_URL,
  PURCHASE_SUCCESS_REDIRECT_URL,
} from "~/constants/url";
import type { ContextInject } from "~/context";
import type {
  PackMapper,
  UserTradingCardMapper,
} from "~/graphql/pack/schema.mappers";
import type { PaymentTransactionMapper } from "~/graphql/payment/schema.mappers";
import type {
  CreateViewerPaymentMethodCardInput,
  PaymentMethodCard,
  PaymentStatus,
  PurchaseByPaymentMethodCardInput,
  PurchaseByPaymentMethodCardResponse,
  PurchaseByPaymentMethodPayPayInput,
  PurchaseByPaymentMethodPayPayResponse,
} from "~/graphql/types.generated";
import { PackDataSource } from "~/usecase/pack";
import { assertAuthenticated } from "~/utils/assertAuthenticated";
import { assertExists } from "~/utils/assetExists";
import {
  createFincodeCard,
  createFincodePayment,
  createFincodeUser,
  executeFincodePaymentByCard,
  executeFincodePaymentByPayPay,
  getFincodeCard,
  getFincodeCardList,
  getFincodeUser,
  isFincodeError,
} from "~/utils/fincode";
import { logger } from "~/utils/logger";

export class PaymentDataSource {
  private context: ContextInject;

  public constructor(context: ContextInject) {
    this.context = context;
  }

  // ログインユーザーの決済手段（カード）一覧を取得する。
  public async getViewerPaymentMethodCards(): Promise<PaymentMethodCard[]> {
    const uid = assertAuthenticated(this.context.uid);

    try {
      // NOTE: 決済手段一覧だが、カード決済しか現在存在しないのでカードのリストを返す
      const cards = await getFincodeCardList(uid);
      if (!cards) {
        return [];
      }

      return cards.map(
        (card) =>
          ({
            type: "CARD",
            cardId: card.id,
            cardNo: card.card_no,
            cardBrand: card.brand as string | null,
          }) satisfies PaymentMethodCard,
      );
    } catch (error) {
      logger.error("failed to get payment method cards", error, { uid });

      return [];
    }
  }

  // ログインユーザーの決済履歴一覧を取得する。
  public async getViewerPaymentTransactions(): Promise<
    PaymentTransactionMapper[]
  > {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const paymentTransactions =
      await repo.findManyPaymentTransactionsByUserIdWithPaymentMethod(uid);

    return paymentTransactions.map((paymentTransaction) => ({
      ...paymentTransaction,
      status: paymentTransaction.status as PaymentStatus,
      method: {
        ...paymentTransaction.paymentMethod,
      },
    }));
  }

  // 指定されたOrderIDからログインユーザーの決済履歴を取得する。
  public async getViewerPaymentTransactionByOrderId(
    orderId: string,
  ): Promise<PaymentTransactionMapper> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const paymentTransaction =
      await repo.findFirstPaymentTransactionByUserIdAndOrderIdWithPaymentMethod(
        uid,
        orderId,
      );
    assertExists(paymentTransaction, "PaymentTransaction");

    return {
      ...paymentTransaction,
      status: paymentTransaction.status as PaymentStatus,
      method: {
        ...paymentTransaction.paymentMethod,
      },
    };
  }

  // 指定された決済履歴に紐づくパック情報を取得する。
  public async getViewerPackByPaymentTransactionId(
    id: number,
  ): Promise<PackMapper> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const paymentTransaction =
      await repo.findFirstPaymentTransactionByIdAndUserIdWithPack(id, uid);
    assertExists(paymentTransaction, "PaymentTransaction");

    return paymentTransaction.pack;
  }

  // 指定された決済履歴に紐づくトレーディングカード情報を取得する。
  public async getViewerTradingCardsByPaymentTransactionId(
    id: number,
  ): Promise<UserTradingCardMapper[]> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const userTradingCards =
      await repo.findManyUserTradingCardsByPaymentTransactionIdAndUserIdWithTradingCard(
        id,
        uid,
      );

    const cards: UserTradingCardMapper[] = [];

    for (const card of userTradingCards) {
      cards.push({
        ...card,
        id: card.id,
        name: card.tradingCard.name,
        imageURL: card.tradingCard.imageURL,
        backImageURL: card.tradingCard.backImageURL,
        usedImageURL: card.tradingCard.usedImageURL,
      });
    }

    return cards;
  }

  // ログインユーザーの決済手段（カード）を作成する。
  public async createViewerPaymentMethodCard(
    input: CreateViewerPaymentMethodCardInput,
  ): Promise<PaymentMethodCard> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    const idempotentKey = input.idempotentKey || undefined;

    try {
      // fincode の顧客情報を取得する
      let fincodeUser = await getFincodeUser(uid);
      if (!fincodeUser) {
        // fincode に新規顧客として登録する
        fincodeUser = await createFincodeUser(user, idempotentKey);
      }

      const result = await createFincodeCard({
        customerId: uid,
        token: input.creditCardToken,
        idempotentKey,
      });

      return {
        __typename: "PaymentMethodCard",
        type: "CARD",
        cardId: result.id,
        cardNo: result.card_no,
        cardBrand: result.brand,
      };
    } catch (error) {
      logger.error("failed to create payment method card", error, {
        uid,
        input,
      });

      if (isFincodeError(error)) {
        const message = error.errors.at(-1);
        logger.error("failed to create payment method card", {
          uid,
          input,
          fincodeError: message,
        });

        throw new GraphQLError(message?.error_message || error.name, {
          extensions: {
            code: "FINCODE_API_ERROR",
            errorCode: message?.error_code,
            exceeded: error.exceeded,
          },
        });
      }

      throw new GraphQLError("Failed to create credit card", {
        extensions: { code: "INTERNAL_SERVER_ERROR" },
      });
    }
  }

  // クレジットカードで購入する。
  public async purchaseByPaymentMethodCard(
    input: PurchaseByPaymentMethodCardInput,
  ): Promise<PurchaseByPaymentMethodCardResponse> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    if (
      !Number.isInteger(input.quantity) ||
      ![1, 5, 10].includes(input.quantity)
    ) {
      logger.warn("Invalid quantity", { uid, input });
      throw new GraphQLError("Invalid quantity", {
        extensions: { code: "INVALID_QUANTITY" },
      });
    }

    const packDataSource = new PackDataSource(this.context);
    if (!(await packDataSource.isPackPurchasable(input.packId))) {
      logger.warn("Pack is not purchasable", { uid, input });
      throw new GraphQLError("Pack is not purchasable", {
        extensions: { code: "NOT_PURCHASABLE" },
      });
    }

    const idempotentKey = input.idempotentKey || undefined;

    try {
      // fincode の顧客情報を取得する
      let fincodeUser = await getFincodeUser(uid);
      if (!fincodeUser) {
        // fincode に新規顧客として登録する
        fincodeUser = await createFincodeUser(user, idempotentKey);
      }

      // 合計金額を計算する
      const totalPrice = await this.calculateTotalPrice(
        input.packId,
        input.quantity,
      );

      // fincode に決済を作成する
      const fincodePayment = await createFincodePayment({
        payType: "Card",
        amount: totalPrice,
        idempotentKey,
      });

      const card = await getFincodeCard(uid, input.cardId);
      assertExists(card, "Card");

      return await repo.withTransaction(async (tx) => {
        // 未処理状態でDBに保存する
        const paymentMethod = await repo.createPaymentMethod(
          {
            userId: uid,
            type: "CARD",
            cardId: card.id,
            cardNo: card.card_no,
            cardBrand: card.brand,
          },
          { tx },
        );

        const paymentTransaction = await repo.createPaymentTransaction(
          {
            totalPrice,
            quantity: input.quantity,
            orderId: fincodePayment.id,
            accessId: fincodePayment.access_id,
            status: fincodePayment.status,
            paymentMethodId: paymentMethod.id,
            packId: input.packId,
            userId: uid,
          },
          { tx },
        );

        try {
          // fincode の決済を実行する
          const executedPayment = await executeFincodePaymentByCard(
            fincodePayment.id,
            {
              accessId: fincodePayment.access_id,
              customerId: fincodeUser.id,
              cardId: card.id,
              paymentTransactionId: paymentTransaction.id,
              orderId: fincodePayment.id,
              packId: input.packId,
              quantity: input.quantity,
              idempotentKey,
            },
          );

          // 決済実行で3Dセキュア認証のために status を更新する
          await repo.updatePaymentTransactionStatus(
            paymentTransaction.id,
            executedPayment.status,
            { tx },
          );

          if (!("acs_url" in executedPayment)) {
            logger.warn("3D Secure authentication is required", {
              uid,
              input,
              paymentMethod,
              paymentTransaction,
              executedPayment,
            });
            throw new GraphQLError("3D Secure authentication is required", {
              extensions: { code: "THREE_D_SECURE_REQUIRED" },
            });
          }

          return {
            // NOTE: fincode sdk が acs_url の定義がされてないため、any でキャストする
            // ref: https://docs.fincode.jp/api#tag/%E6%B1%BA%E6%B8%88/operation/executePayment
            // biome-ignore lint/suspicious/noExplicitAny: <explanation>
            acs_url: (executedPayment as any).acs_url,
          };
        } catch (error) {
          logger.error("failed to execute payment", error, { uid, input });

          // 決済実行に失敗した場合、DBのステータスを失敗に更新する
          await repo.updatePaymentTransactionStatus(
            paymentTransaction.id,
            "FAILED",
            { tx },
          );

          if (isFincodeError(error)) {
            const message = error.errors.at(-1);
            logger.error("failed to execute payment", {
              uid,
              input,
              paymentMethod,
              paymentTransaction,
              fincodeError: message,
            });
            throw new GraphQLError(message?.error_message || error.name, {
              extensions: {
                code: "FINCODE_API_ERROR",
                errorCode: message?.error_code,
                exceeded: error.exceeded,
              },
            });
          }

          throw new GraphQLError((error as Error).message, {
            extensions: {
              code: "INTERNAL_SERVER_ERROR",
              name: (error as Error).name,
            },
          });
        }
      });
    } catch (error) {
      logger.error("failed to purchase by credit card", error, { uid, input });

      // エラーが GraphQL エラーの場合はそのままスローする
      if (error instanceof GraphQLError) {
        throw error;
      }

      // エラーが FincodeAPIError の場合は code を FINCODE_API_ERROR に変更してスローする
      if (isFincodeError(error)) {
        const message = error.errors.at(-1);
        logger.error("failed to purchase by credit card", {
          uid,
          input,
          fincodeError: message,
        });
        throw new GraphQLError(message?.error_message || error.name, {
          extensions: {
            code: "FINCODE_API_ERROR",
            errorCode: message?.error_code,
            exceeded: error.exceeded,
          },
        });
      }

      throw new GraphQLError("Failed to purchase by credit card", {
        extensions: { code: "INTERNAL_SERVER_ERROR" },
      });
    }
  }

  // PayPayで購入する。
  public async purchaseByPaymentMethodPayPay(
    input: PurchaseByPaymentMethodPayPayInput,
    options: {
      isSignage: boolean;
      pairingSessionId: string;
    } = {
      isSignage: false,
      pairingSessionId: "",
    },
  ): Promise<PurchaseByPaymentMethodPayPayResponse> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.payment;

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    if (
      !Number.isInteger(input.quantity) ||
      ![1, 5, 10].includes(input.quantity)
    ) {
      logger.warn("Invalid quantity", { uid, input });
      throw new GraphQLError("Invalid quantity", {
        extensions: { code: "INVALID_QUANTITY" },
      });
    }

    const packDataSource = new PackDataSource(this.context);
    if (!(await packDataSource.isPackPurchasable(input.packId))) {
      logger.warn("Pack is not purchasable", { uid, input });
      throw new GraphQLError("Pack is not purchasable", {
        extensions: { code: "NOT_PURCHASABLE" },
      });
    }

    const idempotentKey = input.idempotentKey || undefined;

    try {
      // fincode の顧客情報を取得する
      let fincodeUser = await getFincodeUser(uid);
      if (!fincodeUser) {
        // fincode に新規顧客として登録する
        fincodeUser = await createFincodeUser(user, idempotentKey);
      }

      // 合計金額を計算する
      const totalPrice = await this.calculateTotalPrice(
        input.packId,
        input.quantity,
      );

      // fincode に決済を作成する
      const fincodePayment = await createFincodePayment({
        payType: "Paypay",
        amount: totalPrice,
        idempotentKey,
      });

      return await repo.withTransaction(async (tx) => {
        // 未処理状態でDBに保存する
        const paymentMethod = await repo.createPaymentMethod(
          {
            userId: uid,
            type: "PAYPAY",
          },
          { tx },
        );

        const paymentTransaction = await repo.createPaymentTransaction(
          {
            totalPrice,
            quantity: input.quantity,
            orderId: fincodePayment.id,
            accessId: fincodePayment.access_id,
            status: fincodePayment.status,
            paymentMethodId: paymentMethod.id,
            packId: input.packId,
            userId: uid,
          },
          { tx },
        );

        // signage の場合、 pairing table に order の情報を追加する
        if (options.isSignage) {
          await tx.pairing.update({
            where: {
              pairingSessionId: options.pairingSessionId,
            },
            data: {
              paymentTransactionId: paymentTransaction.id,
            },
          });
        }

        try {
          // fincode の決済を実行する
          const executePayment = await executeFincodePaymentByPayPay(
            fincodePayment.id,
            {
              accessId: fincodePayment.access_id,
              customerId: fincodeUser.id,
              paymentTransactionId: paymentTransaction.id,
              redirectUrl: options.isSignage
                ? PURCHASE_SIGNAGE_REDIRECT_URL(fincodePayment.id)
                : PURCHASE_SUCCESS_REDIRECT_URL(fincodePayment.id),
              orderId: fincodePayment.id,
              packId: input.packId,
              quantity: input.quantity,
              idempotentKey,
            },
          );

          const redirect_url = executePayment.code_url;

          if (!redirect_url) {
            logger.warn("Failed to purchase by PayPay", {
              uid,
              input,
              paymentMethod,
              paymentTransaction,
              executePayment,
            });
            throw new GraphQLError("Failed to purchase by PayPay", {
              extensions: { code: "INTERNAL_SERVER_ERROR" },
            });
          }

          return {
            redirect_url,
          };
        } catch (error) {
          logger.error("failed to purchase by PayPay", error, { uid, input });

          // 決済実行に失敗した場合、DBのステータスを失敗に更新する
          await repo.updatePaymentTransactionStatus(
            paymentTransaction.id,
            "FAILED",
            { tx },
          );

          if (isFincodeError(error)) {
            const message = error.errors.at(-1);
            logger.error("failed to purchase by PayPay", {
              uid,
              input,
              paymentMethod,
              paymentTransaction,
              fincodeError: message,
            });
            throw new GraphQLError(message?.error_message || error.name, {
              extensions: {
                code: "FINCODE_API_ERROR",
                errorCode: message?.error_code,
                exceeded: error.exceeded,
              },
            });
          }

          throw new GraphQLError((error as Error).message, {
            extensions: {
              code: "INTERNAL_SERVER_ERROR",
              name: (error as Error).name,
            },
          });
        }
      });
    } catch (error) {
      logger.error("failed to purchase by PayPay", error, { uid, input });

      // エラーが GraphQL エラーの場合はそのままスローする
      if (error instanceof GraphQLError) {
        throw error;
      }

      // エラーが FincodeAPIError の場合は code を FINCODE_API_ERROR に変更してスローする
      if (isFincodeError(error)) {
        const message = error.errors.at(-1);
        logger.error("failed to purchase by PayPay", {
          uid,
          input,
          fincodeError: message,
        });
        throw new GraphQLError(message?.error_message || error.name, {
          extensions: {
            code: "FINCODE_API_ERROR",
            errorCode: message?.error_code,
            exceeded: error.exceeded,
          },
        });
      }

      throw new GraphQLError("Failed to purchase by paypay", {
        extensions: { code: "INTERNAL_SERVER_ERROR" },
      });
    }
  }

  // 指定されたパックIDと数量から合計金額を計算する
  public async calculateTotalPrice(
    packId: string,
    quantity: number,
  ): Promise<number> {
    const repo = this.context.repository.payment;
    const packPrices = await repo.findManyPackPricesByPackId(packId);
    if (packPrices.length === 0) {
      logger.error("Pack price is not set", { packId, quantity });
      throw new GraphQLError("Pack price is not set", {
        extensions: { code: "INTERNAL_SERVER_ERROR" },
      });
    }

    // パックの価格を取得
    const packPrice = packPrices[0].price;

    // 5パック、10パック購入時は20%OFF
    if (quantity === 1) {
      return packPrice;
    }
    if (quantity === 5) {
      return Math.floor(packPrice * 5 * 0.8);
    }
    if (quantity === 10) {
      return Math.floor(packPrice * 10 * 0.8);
    }

    logger.error("Invalid quantity for pack purchase", { packId, quantity });
    throw new GraphQLError("Invalid quantity for pack purchase", {
      extensions: { code: "BAD_REQUEST" },
    });
  }
}

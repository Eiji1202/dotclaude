import { PairingStatus } from "@/prisma/generated";
import { randomUUID } from "node:crypto";
import type { Request, Response } from "express";
import jwt from "jsonwebtoken";
import type { ContextInject } from "~/context";
import { repository, sideEffect } from "~/context";
import { PackDataSource } from "~/usecase/pack";
import { config } from "~/utils/config";
import { prisma } from "~/utils/prisma";

export async function grantPack(req: Request, res: Response) {
  const { uid, pairingSessionId, packId, quantity } = req.body as {
    uid: string;
    pairingSessionId: string;
    packId: string;
    quantity: number;
  };

  const pairing = await prisma.pairing.findUnique({
    where: {
      pairingSessionId,
      uid,
      status: PairingStatus.USING,
    },
  });

  // validation
  if (!pairing) return res.status(404).json({ message: "Pairing not found" });
  if (pairing.status !== "USING")
    return res.status(400).json({ message: "Pairing is not using" });
  if (pairing.uid !== uid)
    return res.status(400).json({ message: "Pairing is not owned by you" });
  if (pairing.token == null)
    return res.status(400).json({ message: "Pairing token is not set" });

  try {
    // jwt verify で decode できない場合、 throw されるので try-catch
    const decoded = jwt.verify(
      pairing.token,
      process.env.SIGNAGE_JWT_SECRET,
    ) as {
      pairingSessionId: string;
      uid: string;
    };
    if (decoded.pairingSessionId !== pairingSessionId || decoded.uid !== uid)
      return res.status(400).json({ message: "Pairing token is not valid" });
  } catch {
    return res.status(400).json({ message: "Pairing token is expired" });
  }

  const context: ContextInject = {
    sideEffect,
    config,
    repository,
    uid,
  };

  const packUsecase = new PackDataSource(context);

  try {
    const paymentTransaction = await prisma.$transaction(async (tx) => {
      const pm = await repository.pack.createPaymentMethod(
        {
          userId: uid,
          type: "CAMPAIGN",
        },
        { tx },
      );

      const orderId = `grant-signage-${pairingSessionId}-${packId}-${uid}-${randomUUID().replace(/-/g, "")}`;
      const ptx = await repository.pack.createCampaignPaymentTransaction(
        {
          userId: uid,
          orderId,
          paymentMethodId: pm.id,
          packId,
          totalPrice: 0,
          quantity,
        },
        { tx },
      );

      await tx.pairing.update({
        where: {
          pairingSessionId,
        },
        data: {
          paymentTransactionId: ptx.id,
        },
      });

      const pack = await repository.pack.findUniquePack(packId, { tx });
      if (!pack) throw new Error("Pack not found");

      const utc = await packUsecase.selectRandomTradingCardIdsByPackId(
        "payment",
        packId,
        quantity * pack.paymentGrantCardQuantity,
      );

      await tx.userTradingCard.createMany({
        data: utc.map((tc) => {
          const id = randomUUID().split("-").join("");
          return {
            id,
            userId: uid,
            tradingCardId: tc,
            paymentTransactionId: ptx.id,
            pairingSessionId,
          };
        }),
      });

      return ptx;
    });

    return res.status(200).json(paymentTransaction);
  } catch {
    return res.status(500).json({ message: "Failed to grant pack" });
  }
}

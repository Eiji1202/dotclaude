# マルチテナントアーキテクチャ デザインドキュメント

## 1. 概要 (Overview)

- **目的**: 本プロジェクトは、単一のプロダクト基盤を複数の独立したブランドへ横展開可能にするためのマルチテナント化対応である。データベースレベルでテナント間のデータを厳格に分離し、安全かつスケーラブルなアーキテクチャを構築することを目的とする。
- **背景**: 現在のシステムはシングルテナントを前提としており、複数の IP ブランドが混ざる状態でしかサービスを展開できず、クライアント獲得の障害になっている。
- **ドキュメントのステータス**: `[Draft]`

---

## 2. ゴールと非ゴール (Goals and Non-Goals)

### 2.1 ゴール (必須条件)

- [x] **データの厳格な分離**: アプリケーション層のバグが原因で、他テナントのデータが絶対に漏洩しないこと。
- [x] **透過的な実装**: アプリケーション開発者が、テナント分離を意識せずにビジネスロジックの実装に集中できること。
- [x] **開発効率の向上**: 新規 IP の立ち上げを、DB へのレコード追加とドメイン設定のみで迅速に行えるようにする。
- [x] **テナントごとの認証**: IP ごとに独立した認証（Firebase Tenant）を提供し、ユーザーベースを分離する。

### 2.2 非ゴール (スコープ外)

- **テナントごとの完全なインフラ分離**: テナントごとに異なる DB インスタンスや、マイクロサービスをデプロイすることはスコープ外とする。インフラは全テナントで共有する。
- **テナントごとの UI 完全カスタマイズ**: テナントごとに UI テーマやレイアウトを大幅に変更する機能はスコープ外とする。コンポーネントやアセットの差し替えに留める。今後、Feature Flag の導入によるテナントごとの機能切り替えは想定する。
- **テナントごとのパフォーマンス保証**: 特定のテナントに占有リソースを割り当てることはしない。リソースは全テナントで共有する。

---

## 3. システム設計 (System Design)

### 3.1 全体アーキテクチャ

テナントの識別はサブドメインで行い、DB レベルでのデータ分離は**PostgreSQL の Row Level Security (RLS)**を主軸とする。

1.  **アクセス**: ユーザーが `artist-a.example.com` にアクセス。
2.  **テナント特定**: フロントエンドがホスト名から Firebase Tenant ID を特定。
3.  **認証**: 特定された Tenant ID を用いて Firebase Auth で認証し、`firebase.tenant` クレームを含む JWT を取得。
4.  **API リクエスト**: フロントエンドは API リクエストのヘッダーに JWT を含める。
5.  **テナントコンテキスト設定**: バックエンドのミドルウェアが JWT を検証し、テナント ID（`tenant_id`）を取得。DB コネクションのスコープ内で `SET LOCAL app.current_tenant_id = '...'` を実行し、RLS を有効化する。

### 3.2 詳細ロジック / バックエンド実装

#### 3.2.1. Go Backend (`packages/api`)

Connect RPC のインターセプターを利用して RLS を透過的に適用する。DB 接続プールからコネクションを取得する際にフックし、`SET LOCAL`コマンドを実行する。

#### 3.2.2. Node.js/Prisma Backend (`packages/backend`)

Prisma のクライアント拡張（`$extends`）を利用し、テナント ID を要求する新しいクライアント（Tenant-Aware Prisma Client）をリクエストごとに生成する。このクライアントは、全てのクエリをトランザクション内で実行し、第一ステップとして`SET LOCAL`を発行することで、安全かつ透過的に RLS を適用する。

```typescript
// lib/prisma.ts (拡張クライアントの定義)
export function createTenantClient(tenantId: string) {
  return prisma.$extends({
    query: {
      $allModels: {
        async $allOperations({ model, operation, args, query }) {
          const [, result] = await prisma.$transaction([
            prisma.$executeRawUnsafe(
              `SET LOCAL app.current_tenant_id = '${tenantId}'`
            ),
            query(args),
          ]);
          return result;
        },
      },
    },
  });
}
```

---

## 4. データ設計 (Data Design)

### 4.1 スキーマ変更 / モデル定義

#### 4.1.1. `Tenant` テーブル（新規）

テナント情報を一元管理するマスタテーブル。

```prisma
model Tenant {
  id               String    @id @default(cuid())
  firebaseTenantId String    @unique @map("firebase_tenant_id")
  subdomain        String    @unique
  name             String
  // ...
}
```

#### 4.1.2. 既存テーブルへの `tenant_id` 追加

`Event`, `Pack`, `User`など、テナントごとに分離されるべきすべてのテーブルに`tenant_id`カラム（`Tenant`への FK）を追加する。

### 4.2 RLS ポリシー定義

`app.current_tenant_id`というセッション変数を使い、アクセス可能な行を DB レベルで制限する。

```sql
-- 対象テーブルでRLSを有効化
ALTER TABLE "Event" ENABLE ROW LEVEL SECURITY;

-- INSERTとSELECT/UPDATE/DELETEの両方に適用されるポリシーを作成
CREATE POLICY tenant_isolation_policy ON "Event"
    FOR ALL
    USING ("tenant_id" = current_setting('app.current_tenant_id'))
    WITH CHECK ("tenant_id" = current_setting('app.current_tenant_id'));
```

---

## 5. 検討した代替案 (Alternatives Considered)

| 案                                                                | メリット                                                                                                                                   | デメリット                                                                                                                | 評価                           |
| :---------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------ | :----------------------------- |
| **案 A: アプリケーション層での分離** (`WHERE`句の徹底)            | ・実装が直感的で、特別な DB 機能が不要。<br>・ORM との親和性が高い。                                                                       | ・`WHERE`句の記述漏れが致命的な情報漏洩に直結する。<br>・コードレビューでの検出が困難で、ヒューマンエラーのリスクが高い。 | △                              |
| **案 B: RLS (Row Level Security)**                                | ・DB 層でデータ分離を強制するため、アプリ層のバグに強い。<br>・`SET LOCAL`により実装をミドルウェアに集約でき、開発者はテナントを意識不要。 | ・ORM（特に Prisma）との連携に工夫が必要。<br>・`SET LOCAL`のオーバーヘッドがわずかに発生する。                           | **◎ (採用)**                   |
| **案 C: スキーマ分離** (テナントごとに PostgreSQL スキーマを分離) | ・テナント間の分離がより強力。<br>・テーブル名が同じなのでアプリの修正が少ない。                                                           | ・Prisma でのスキーマ動的切り替えのサポートが限定的。<br>・マイグレーションがテナント数分必要になり、運用が複雑化する。   | 〇                             |
| **案 D: データベース分離** (テナントごとに DB インスタンスを分離) | ・物理的に分離されるため、最も安全でパフォーマンス影響もない。                                                                             | ・テナントごとにインフラコストがかかる。<br>・DB プロビジョニングやコネクション管理が非常に複雑になる。                   | × (コスト・運用面で見合わない) |

**評価結論**:
`案 B: RLS`は、`案 A`の致命的なセキュリティリスクを DB レベルでカバーしつつ、`案 C, D`ほどの運用・コスト増を招かないため、本プロジェクトの要件（安全性と開発効率の両立）にとって最もバランスの取れた最適な解決策である。

---

## 6. 横断的な懸念事項 (Cross-cutting Concerns)

- **セキュリティ**: RLS により、`WHERE`句のつけ忘れによる情報漏洩リスクを根本的に排除。SQL インジェクション対策として、`SET LOCAL`で設定する`tenant_id`は必ずバックエンド内部で検証・生成された値のみを使用する。
- **信頼性・可用性**: `createTenantClient`に`tenantId`が渡されない場合は即時エラーとし、不正な状態での DB アクセスを防ぐ。
- **パフォーマンス**: 各クエリでの`SET LOCAL`実行によるオーバーヘッドは軽微であり、アプリケーション全体のパフォーマンスに大きな影響を与える可能性は低いと判断。`tenant_id`カラムには必ずインデックスを作成する。

---

## 7. 移行・デプロイ・運用計画 (Deployment & Operations)

1.  **Phase 1: スキーマ変更**: `Tenant`テーブル作成と`tenant_id`カラム追加（NULL 許容）。既存データにデフォルト値をバックフィル後、`NOT NULL`制約を追加。
2.  **Phase 2: バックエンド対応**: RLS 適用ロジックを実装。ただし、RLS ポリシーはまだ有効化しない（Dry Run モード）。
3.  **Phase 3: RLS 有効化**: テスト環境でポリシーの有効性を確認後、本番環境で有効化。
4.  **Phase 4: リファクタリング**: RLS が機能していることを確認後、アプリケーションコードから冗長な`WHERE tenant_id = ...`句を順次削除。

- **監視**: テナントごとのリクエスト数やエラー率を監視できるメトリクスを追加する。
- **切り戻し（Rollback）**: RLS ポリシーに問題が発覚した場合、`ALTER TABLE "TableName" DISABLE ROW LEVEL SECURITY;`を実行することで、ポリシーを一時的に無効化する手順を準備する。

---

## 8. 未解決事項 (Open Questions)

- [ ] フロントエンドがサブドメインから Firebase Tenant ID を解決するための具体的な方法（ビルド時埋め込み or API 経由）の最終決定。

---

## 9. 参考資料 (References)

- (リンク) PRD - マルチテナント対応
- (リンク) Firebase - Authenticate with Identity Platform multi-tenancy
- (リンク) PostgreSQL - Row Security Policies
- (リンク) Prisma - `$extends` documentation

---

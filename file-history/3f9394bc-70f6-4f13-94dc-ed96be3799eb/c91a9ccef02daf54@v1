import { GraphQLError } from "graphql";
import type { ContextInject } from "~/context";
import type { UserCertificateMapper } from "~/graphql/event/schema.mappers";
import type { UserTradingCardMapper } from "~/graphql/pack/schema.mappers";
import type {
  CreateUserByEmailInput,
  UpdateUserInput,
} from "~/graphql/types.generated";
import type {
  PublicUserMapper,
  UserMapper,
} from "~/graphql/user/schema.mappers";
import { assertAuthenticated } from "~/utils/assertAuthenticated";
import { assertExists } from "~/utils/assetExists";

export class UserDataSource {
  private context: ContextInject;

  public constructor(context: ContextInject) {
    this.context = context;
  }

  // ログインユーザーのユーザー情報を取得する。
  public async getViewer(): Promise<UserMapper> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.user;

    const user = await repo.findUniqueUserById(uid);
    assertExists(user, "User");

    return user;
  }

  // ログインユーザーが所有するデジタルパス一覧を取得する。
  public async getViewerCertificates(): Promise<UserCertificateMapper[]> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.user;

    return repo.findManyUserCertificates(uid);
  }

  // ログインユーザーが所有するデジタルトレカ一覧を取得する。
  public async getViewerTradingCards(): Promise<UserTradingCardMapper[]> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.user;

    const userTradingCards = await repo.findManyUserTradingCardsByUserId(uid);

    return userTradingCards.map((card) => ({
      ...card,
      id: card.id.toString(),
      tradingCardId: card.tradingCardId,
      name: card.tradingCard.name,
      imageURL: card.tradingCard.imageURL,
      backImageURL: card.tradingCard.backImageURL,
      usedImageURL: card.tradingCard.usedImageURL,
    }));
  }

  // ユーザーが所有するデジタルパス一覧を取得する。（認証不要）
  public async getUserCertificates(
    userId: string,
  ): Promise<UserCertificateMapper[]> {
    const repo = this.context.repository.user;
    return repo.findManyUserCertificates(userId);
  }

  // ユーザーが所有するデジタルトレカ一覧を取得する。（認証不要）
  public async getUserTradingCards(
    userId: string,
  ): Promise<UserTradingCardMapper[]> {
    const repo = this.context.repository.user;
    const userTradingCards =
      await repo.findManyUserTradingCardsByUserId(userId);

    return userTradingCards.map((card) => ({
      ...card,
      id: card.id.toString(),
      tradingCardId: card.tradingCardId,
      name: card.tradingCard.name,
      imageURL: card.tradingCard.imageURL,
      backImageURL: card.tradingCard.backImageURL,
      usedImageURL: card.tradingCard.usedImageURL,
    }));
  }

  // メールアドレス認証でユーザーを作成する。
  public async createUserByEmail(
    input: CreateUserByEmailInput,
  ): Promise<UserMapper> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.user;

    return repo.upsertUserByEmail({
      id: uid,
      name: input.name ?? "",
      imageURL:
        input.imageURL ??
        "https://storage.googleapis.com/utage3/assets/default-icon.png",
      email: input.email,
    });
  }

  // ログインユーザーのユーザー情報を更新する。
  public async updateUser(input: UpdateUserInput): Promise<UserMapper> {
    const uid = assertAuthenticated(this.context.uid);
    const repo = this.context.repository.user;

    return await repo.withTransaction(async (tx) => {
      const user = await repo.findUniqueUserById(uid, { tx });
      assertExists(user, "User");

      // nicknameの重複チェック
      if (input.nickname && input.nickname !== user.nickname) {
        const existingUser = await repo.findUniqueUserByNickname(
          input.nickname,
          { tx },
        );
        if (existingUser) {
          throw new GraphQLError("このニックネームは既に使用されています", {
            extensions: { code: "NICKNAME_ALREADY_EXISTS" },
          });
        }
      }

      return repo.updateUser(
        {
          id: uid,
          name: input.name ?? user.name ?? undefined,
          imageURL: input.imageURL ?? user.imageURL ?? undefined,
          nickname: input.nickname ?? user.nickname ?? undefined,
        },
        { tx },
      );
    });
  }

  // ニックネームでユーザー情報を取得する。
  public async getUserInfoByNickname(
    nickname: string,
  ): Promise<PublicUserMapper | null> {
    const repo = this.context.repository.user;
    return repo.findUniqueUserByNickname(nickname);
  }
}
